# Supabase Helm Chart - AWS EKS Configuration
# Optimized for AWS EKS with External RDS, S3, and External Secrets

# Security configuration - External Secrets from AWS Secrets Manager
secret:
  jwt:
    enabled: true
  db:
    enabled: true
    autoSecretArn: "rds!db-44a4708a-116b-44d0-b4f9-dedf908c3ca9"
  analytics:
    enabled: true
  dashboard:
    enabled: true
  s3:
    enabled: false  # Using IRSA instead of access keys
  smtp:
    enabled: false

# Database configuration
# Set db.enabled: true to use internal PostgreSQL database
# Set db.enabled: false to use external database (RDS, etc.)
db:
  enabled: false  # Using external RDS PostgreSQL
  # Internal database configuration (only used when db.enabled: true)
  replicaCount: 1
  image:
    repository: supabase/postgres
    tag: "15.1.0.117"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    POSTGRES_PORT: "5432"
    POSTGRES_HOST: "0.0.0.0"
    POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
  service:
    type: ClusterIP
    port: 5432
  persistence:
    enabled: true
    size: 20Gi
    storageClass: ""
    accessModes:
      - ReadWriteOnce
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80
  # External database configuration (only used when db.enabled: false)
  external:
    # Database connection details for external database
    # These values can be overridden by secrets
    host: "" # Will be populated from secret if not provided
    port: "5432"
    database: "postgres"
    username: "postgres"
    password: "postgres" # Only used for internal DB when secret.db.enabled: false
    # SSL configuration for external database
    sslmode: "require" # disable, allow, prefer, require, verify-ca, verify-full

# Studio Application - Supabase Dashboard
studio:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/studio
    tag: "2025.09.15-sha-6cff20b"
    pullPolicy: IfNotPresent
  environment:
    STUDIO_DEFAULT_ORGANIZATION: "Default Organization"
    STUDIO_DEFAULT_PROJECT: "Default Project" 
    STUDIO_PORT: "3000"
    SUPABASE_PUBLIC_URL: "https://supabase.stack-ai.jesuspaz.com"
    NEXT_PUBLIC_ENABLE_LOGS: "true"
    NEXT_ANALYTICS_BACKEND_PROVIDER: "postgres"
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  service:
    type: ClusterIP
    port: 3000
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80

# Auth Service - GoTrue Authentication
auth:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/gotrue
    tag: "v2.179.0"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    DB_PORT: "5432"
    DB_DRIVER: "postgres"
    DB_SSL: "disable"
    API_EXTERNAL_URL: "https://supabase.stack-ai.jesuspaz.com"
    GOTRUE_API_HOST: "0.0.0.0"
    GOTRUE_API_PORT: "9999"
    GOTRUE_SITE_URL: "https://supabase.stack-ai.jesuspaz.com"
    GOTRUE_URI_ALLOW_LIST: "*"
    GOTRUE_DISABLE_SIGNUP: "false"
    GOTRUE_JWT_DEFAULT_GROUP_NAME: "authenticated"
    GOTRUE_JWT_ADMIN_ROLES: "service_role"
    GOTRUE_JWT_AUD: "authenticated"
    GOTRUE_JWT_EXP: "3600"
    GOTRUE_EXTERNAL_EMAIL_ENABLED: "true"
    GOTRUE_MAILER_AUTOCONFIRM: "true"
    GOTRUE_EXTERNAL_PHONE_ENABLED: "false"
    GOTRUE_SMS_AUTOCONFIRM: "false"
    GOTRUE_MAILER_URLPATHS_INVITE: "/auth/v1/verify"
    GOTRUE_MAILER_URLPATHS_CONFIRMATION: "/auth/v1/verify"
    GOTRUE_MAILER_URLPATHS_RECOVERY: "/auth/v1/verify"
    GOTRUE_MAILER_URLPATHS_EMAIL_CHANGE: "/auth/v1/verify"
    # SMTP Configuration (optional)
    GOTRUE_SMTP_ADMIN_EMAIL: "admin@example.com"
    GOTRUE_SMTP_HOST: "smtp.example.com"
    GOTRUE_SMTP_PORT: "587"
    GOTRUE_SMTP_SENDER_NAME: "Supabase"
  service:
    type: ClusterIP
    port: 9999
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 512Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70

# REST API - PostgREST
rest:
  enabled: true
  replicaCount: 1
  image:
    repository: postgrest/postgrest
    tag: "v12.0.2"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    DB_PORT: "5432"
    DB_DRIVER: "postgres"
    DB_SSL: "disable"
    PGRST_DB_SCHEMAS: "public,storage,graphql_public"
    PGRST_DB_ANON_ROLE: "anon"
    PGRST_DB_USE_LEGACY_GUCS: "false"
    PGRST_APP_SETTINGS_JWT_EXP: "3600"
  service:
    type: ClusterIP
    port: 3000
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 512Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 8
    targetCPUUtilizationPercentage: 70

# Realtime Service - WebSocket subscriptions
realtime:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/realtime
    tag: "v2.20.0"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    DB_PORT: "5432"
    DB_DRIVER: "postgres"
    DB_SSL: "disable"
    DB_AFTER_CONNECT_QUERY: "SET search_path TO realtime"
    PORT: "4000"
    FLY_ALLOC_ID: "fly123"
    FLY_APP_NAME: "realtime"
    SECRET_KEY_BASE: "UpNVntn3cDxHJpq99YMc1T1AQgQpc8kfYTuRgBiYa15BLrx8etQoXz3gZv1/u2oq"
    ERL_AFLAGS: "-proto_dist inet_tcp"
    ENABLE_TAILSCALE: "false"
    DNS_NODES: "''"
  service:
    type: ClusterIP
    port: 4000
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 512Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70

# Meta Service - PostgreSQL metadata API
meta:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/postgres-meta
    tag: "v0.91.6"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    DB_PORT: "5432"
    DB_DRIVER: "postgres"
    DB_SSL: "disable"
    PG_META_PORT: "8080"
  service:
    type: ClusterIP
    port: 8080
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80

# Storage Service - File storage with S3 backend
storage:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/storage-api
    tag: "v0.43.0"
    pullPolicy: IfNotPresent
  environment:
    DB_PORT: "5432"
    DB_DRIVER: "postgres"
    DB_SSL: "disable"
    PGOPTIONS: "-c search_path=storage,public"
    FILE_SIZE_LIMIT: "52428800"
    STORAGE_BACKEND: "s3"  # Using S3 instead of local file storage
    AWS_DEFAULT_REGION: "us-east-1"
    GLOBAL_S3_PROTOCOL: "https"
    GLOBAL_S3_FORCE_PATH_STYLE: "false"
    TENANT_ID: "stub"
    REGION: "stub"
    GLOBAL_S3_BUCKET: "supabase-on-eks-storage-20250918041141008900000005"  # Real S3 bucket from Terraform
    NODE_TLS_REJECT_UNAUTHORIZED: "0"  # Disable SSL certificate validation for development
    AWS_S3_REGION: "us-east-1"  # Explicit S3 region
    AWS_S3_FORCE_PATH_STYLE: "false"  # Use virtual-hosted-style URLs for S3
  serviceAccount:
    create: true
    name: "supabase-storage"
    annotations:
      eks.amazonaws.com/role-arn: "arn:aws:iam::851725652296:role/supabase-on-eks-app-s3-20250918044322522300000007"
  service:
    type: ClusterIP
    port: 5000
  persistence:
    enabled: false  # Using S3, not local storage
    size: 10Gi
    storageClass: ""
    accessModes:
      - ReadWriteOnce
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 512Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 4
    targetCPUUtilizationPercentage: 70

# Image Proxy - Image processing and optimization
imgproxy:
  enabled: true
  replicaCount: 1
  image:
    repository: darthsim/imgproxy
    tag: "v3.17.0"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    IMGPROXY_BIND: ":5001"
    IMGPROXY_LOCAL_FILESYSTEM_ROOT: "/"
    IMGPROXY_USE_ETAG: "true"
    IMGPROXY_ENABLE_WEBP_DETECTION: "true"
  service:
    type: ClusterIP
    port: 5001
  persistence:
    enabled: false  # Imgproxy doesn't need persistent storage
    size: 5Gi
    storageClass: ""
    accessModes:
      - ReadWriteOnce
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80

# Kong Gateway - API Gateway and routing
kong:
  enabled: true
  replicaCount: 1
  image:
    repository: kong
    tag: "3.6.1"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    KONG_DATABASE: "off"
    KONG_DECLARATIVE_CONFIG: "/usr/local/kong/kong.yml"
    KONG_DNS_ORDER: "LAST,A,CNAME"
    KONG_PLUGINS: "request-transformer,cors,key-auth,acl,basic-auth"
    KONG_NGINX_PROXY_PROXY_BUFFER_SIZE: "160k"
    KONG_NGINX_PROXY_PROXY_BUFFERS: "64 160k"
    KONG_LOG_LEVEL: "warn"
  service:
    type: ClusterIP
    port: 8000
  ingress:
    enabled: true
    className: "alb"
    annotations:
      kubernetes.io/ingress.class: alb
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/target-type: ip
      alb.ingress.kubernetes.io/group.name: production
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80},{"HTTPS":443}]'
      alb.ingress.kubernetes.io/ssl-redirect: '443'
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:851725652296:certificate/448e98db-b7cd-4efb-b8d0-94bdf6fb2c6a
      alb.ingress.kubernetes.io/subnets: subnet-0216a3f2ad3743f9c,subnet-006fa14e9d72b0312,subnet-0d53c9c338fb936c6
    hosts:
      - host: supabase.stack-ai.jesuspaz.com
        paths:
          - path: /
            pathType: Prefix
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 512Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 70

# Analytics - Logflare for logs and metrics
analytics:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/logflare
    tag: "1.4.0"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    LOGFLARE_NODE_HOST: "127.0.0.1"
    DB_PORT: "5432"
    DB_DRIVER: "postgresql"
    DB_SSL: "disable"
    DB_SCHEMA: "_analytics"
    LOGFLARE_SINGLE_TENANT: "true"
    LOGFLARE_SUPABASE_MODE: "true"
    FEATURE_FLAG_OVERRIDE: "multibackend=true"
  bigQuery:
    enabled: false
  service:
    type: ClusterIP
    port: 4000
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80

# Vector - Log collection and processing
vector:
  enabled: true
  replicaCount: 1
  image:
    repository: timberio/vector
    tag: "latest-alpine"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  service:
    type: ClusterIP
    port: 9001
  # Vector requires logs from the control plane to function
  volumeMounts:
    - name: pod-logs
      mountPath: /var/log/pods
  volumes:
    - name: pod-logs
      hostPath:
        path: /var/log/pods
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 300m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 2
    targetCPUUtilizationPercentage: 80

# Functions - Edge Functions runtime
functions:
  enabled: true
  replicaCount: 1
  image:
    repository: supabase/edge-runtime
    tag: "v1.58.2"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  environment:
    DB_PORT: "5432"
    DB_DRIVER: "postgresql"
    DB_SSL: "disable"
  service:
    type: ClusterIP
    port: 9000
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80

# Minio - Disabled (using S3 instead)
minio:
  enabled: false
  replicaCount: 1
  image:
    repository: minio/minio
    tag: "RELEASE.2023-09-04T19-57-37Z"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  service:
    type: ClusterIP
    port: 9000
  environment:
    MINIO_ROOT_USER: "minioadmin"
    MINIO_ROOT_PASSWORD: "minioadmin123"
  persistence:
    enabled: false
    size: 10Gi
    storageClass: ""
    accessModes:
      - ReadWriteOnce
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80

# Global settings for all services
global:
  # Common service account settings
  serviceAccount:
    create: true
    annotations: {}
    name: ""
  
  # Common security context
  podSecurityContext: {}
  securityContext: {}
  
  # Common node selection
  nodeSelector: {}
  tolerations: []
  affinity: {}
  
  # Common pod settings
  podAnnotations: {}
  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""
  
  # Common probe settings
  livenessProbe: {}
  readinessProbe: {}